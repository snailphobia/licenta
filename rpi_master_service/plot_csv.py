#!/usr/bin/env python3
"""
WiFi Capture Statistics Plotter
Reads CSV files generated by create_pcap_file.py and creates plots showing packet capture statistics over time.
"""

import argparse
import csv
import os
import sys
import struct
from datetime import datetime
from pathlib import Path
from collections import Counter, defaultdict

import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import pandas as pd
import numpy as np

# Setup logging
import logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class WiFiStatsPlotter:
    def __init__(self):
        self.data = None
        self.figure_size = (12, 8)
        self.dpi = 100
        
    def read_csv_file(self, csv_file):
        """Read and parse the WiFi statistics CSV file."""
        try:
            # Read CSV with pandas for easier handling
            self.data = pd.read_csv(csv_file)
            
            # Validate required columns
            required_columns = ['timestamp', 'elapsed_seconds', 'total_packets', 'packets_per_second']
            missing_columns = [col for col in required_columns if col not in self.data.columns]
            
            if missing_columns:
                raise ValueError(f"Missing required columns: {missing_columns}")
            
            # Convert timestamp to datetime objects
            self.data['datetime'] = pd.to_datetime(self.data['timestamp'])
            
            # Convert numeric columns
            self.data['elapsed_seconds'] = pd.to_numeric(self.data['elapsed_seconds'])
            self.data['total_packets'] = pd.to_numeric(self.data['total_packets'])
            self.data['packets_per_second'] = pd.to_numeric(self.data['packets_per_second'])
            
            logger.info(f"Successfully loaded {len(self.data)} data points from {csv_file}")
            logger.info(f"Time range: {self.data['datetime'].min()} to {self.data['datetime'].max()}")
            logger.info(f"Total packets captured: {self.data['total_packets'].max()}")
            logger.info(f"Max packets/sec: {self.data['packets_per_second'].max():.2f}")
            
            return True
            
        except Exception as e:
            logger.error(f"Error reading CSV file {csv_file}: {e}")
            return False
    
    def create_time_series_plot(self, output_file=None, show_plot=True):
        """Create a time series plot showing packets per second over time."""
        if self.data is None:
            logger.error("No data loaded. Call read_csv_file() first.")
            return False
        
        # Create figure with subplots
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=self.figure_size, dpi=self.dpi)
        fig.suptitle('WiFi Packet Capture Statistics', fontsize=16, fontweight='bold')
        
        # Plot 1: Packets per second over time
        ax1.plot(self.data['datetime'], self.data['packets_per_second'], 
                'b-', linewidth=2, marker='o', markersize=4, alpha=0.7)
        ax1.set_title('Packet Capture Rate Over Time', fontsize=14)
        ax1.set_ylabel('Packets per Second', fontsize=12)
        ax1.grid(True, alpha=0.3)
        ax1.set_xlabel('Time', fontsize=12)
        
        # Format x-axis for time
        ax1.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S'))
        ax1.xaxis.set_major_locator(mdates.MinuteLocator(interval=1))
        plt.setp(ax1.xaxis.get_majorticklabels(), rotation=45)
        
        # Add statistics text
        stats_text = f"Max: {self.data['packets_per_second'].max():.2f} pps\n"
        stats_text += f"Avg: {self.data['packets_per_second'].mean():.2f} pps\n"
        stats_text += f"Min: {self.data['packets_per_second'].min():.2f} pps"
        ax1.text(0.02, 0.98, stats_text, transform=ax1.transAxes, 
                verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))
        
        # Plot 2: Cumulative total packets
        ax2.plot(self.data['datetime'], self.data['total_packets'], 
                'g-', linewidth=2, marker='s', markersize=4, alpha=0.7)
        ax2.set_title('Cumulative Packet Count', fontsize=14)
        ax2.set_ylabel('Total Packets Captured', fontsize=12)
        ax2.set_xlabel('Time', fontsize=12)
        ax2.grid(True, alpha=0.3)
        
        # Format x-axis for time
        ax2.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M:%S'))
        ax2.xaxis.set_major_locator(mdates.MinuteLocator(interval=1))
        plt.setp(ax2.xaxis.get_majorticklabels(), rotation=45)
        
        # Add final count text
        final_count = self.data['total_packets'].iloc[-1]
        duration = self.data['elapsed_seconds'].iloc[-1]
        avg_rate = final_count / duration if duration > 0 else 0
        
        stats_text2 = f"Final Count: {final_count:,} packets\n"
        stats_text2 += f"Duration: {duration:.1f} seconds\n"
        stats_text2 += f"Overall Avg: {avg_rate:.2f} pps"
        ax2.text(0.02, 0.98, stats_text2, transform=ax2.transAxes, 
                verticalalignment='top', bbox=dict(boxstyle='round', facecolor='lightgreen', alpha=0.8))
        
        # Adjust layout
        plt.tight_layout()
        
        # Save plot if output file specified
        if output_file:
            try:
                plt.savefig(output_file, dpi=self.dpi, bbox_inches='tight')
                logger.info(f"Plot saved to: {output_file}")
            except Exception as e:
                logger.error(f"Error saving plot to {output_file}: {e}")
        
        # Show plot if requested
        if show_plot:
            plt.show()
        
        return True
    
    def create_histogram_plot(self, output_file=None, show_plot=True):
        """Create a histogram showing distribution of packets per second."""
        if self.data is None:
            logger.error("No data loaded. Call read_csv_file() first.")
            return False
        
        fig, ax = plt.subplots(1, 1, figsize=(10, 6), dpi=self.dpi)
        
        # Create histogram
        n_bins = min(30, len(self.data) // 2)  # Reasonable number of bins
        n, bins, patches = ax.hist(self.data['packets_per_second'], bins=n_bins, 
                                  alpha=0.7, color='skyblue', edgecolor='black')
        
        ax.set_title('Distribution of Packet Capture Rates', fontsize=14, fontweight='bold')
        ax.set_xlabel('Packets per Second', fontsize=12)
        ax.set_ylabel('Frequency', fontsize=12)
        ax.grid(True, alpha=0.3)
        
        # Add statistics
        mean_pps = self.data['packets_per_second'].mean()
        std_pps = self.data['packets_per_second'].std()
        median_pps = self.data['packets_per_second'].median()
        
        # Add vertical lines for mean and median
        ax.axvline(mean_pps, color='red', linestyle='--', linewidth=2, label=f'Mean: {mean_pps:.2f}')
        ax.axvline(median_pps, color='orange', linestyle='--', linewidth=2, label=f'Median: {median_pps:.2f}')
        
        ax.legend()
        
        # Add statistics text box
        stats_text = f"Mean: {mean_pps:.2f} pps\n"
        stats_text += f"Std Dev: {std_pps:.2f} pps\n"
        stats_text += f"Median: {median_pps:.2f} pps\n"
        stats_text += f"Samples: {len(self.data)}"
        ax.text(0.98, 0.98, stats_text, transform=ax.transAxes, 
                verticalalignment='top', horizontalalignment='right',
                bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.8))
        
        plt.tight_layout()
        
        # Save plot if output file specified
        if output_file:
            try:
                plt.savefig(output_file, dpi=self.dpi, bbox_inches='tight')
                logger.info(f"Histogram saved to: {output_file}")
            except Exception as e:
                logger.error(f"Error saving histogram to {output_file}: {e}")
        
        # Show plot if requested
        if show_plot:
            plt.show()
        
        return True
    
    def create_summary_stats(self):
        """Print summary statistics of the capture session."""
        if self.data is None:
            logger.error("No data loaded. Call read_csv_file() first.")
            return
        
        print("\n" + "="*60)
        print("WIFI CAPTURE SESSION SUMMARY")
        print("="*60)
        
        # Time information
        start_time = self.data['datetime'].min()
        end_time = self.data['datetime'].max()
        duration = self.data['elapsed_seconds'].iloc[-1]
        
        print(f"Session Start:     {start_time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Session End:       {end_time.strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Total Duration:    {duration:.1f} seconds ({duration/60:.1f} minutes)")
        
        # Packet statistics
        total_packets = self.data['total_packets'].iloc[-1]
        max_pps = self.data['packets_per_second'].max()
        min_pps = self.data['packets_per_second'].min()
        avg_pps = self.data['packets_per_second'].mean()
        median_pps = self.data['packets_per_second'].median()
        std_pps = self.data['packets_per_second'].std()
        
        print(f"\nTotal Packets:     {total_packets:,}")
        print(f"Overall Rate:      {total_packets/duration:.2f} packets/sec")
        print(f"Max Rate:          {max_pps:.2f} packets/sec")
        print(f"Min Rate:          {min_pps:.2f} packets/sec")
        print(f"Average Rate:      {avg_pps:.2f} packets/sec")
        print(f"Median Rate:       {median_pps:.2f} packets/sec")
        print(f"Std Deviation:     {std_pps:.2f} packets/sec")
        
        # Data points
        print(f"\nSampling Points:   {len(self.data)}")
        print(f"Sampling Interval: ~{duration/len(self.data):.1f} seconds")
        
        print("="*60 + "\n")
    
    def analyze_pcap_file(self, pcap_file):
        """Analyze a PCAP file to extract packet type statistics."""
        try:
            with open(pcap_file, 'rb') as f:
                # Read PCAP global header
                global_header = f.read(24)
                if len(global_header) < 24:
                    logger.error(f"Invalid PCAP file: {pcap_file}")
                    return None
                
                # Parse global header
                magic, version_major, version_minor, thiszone, sigfigs, snaplen, network = struct.unpack('!IHHIIII', global_header)
                
                if magic != 0xa1b2c3d4:
                    logger.error(f"Invalid PCAP magic number in {pcap_file}")
                    return None
                
                logger.info(f"Analyzing PCAP file: {pcap_file}")
                logger.info(f"Network type: {network} (127 = IEEE 802.11 + Radiotap)")
                
                packet_types = Counter()
                total_packets = 0
                
                while True:
                    # Read packet header
                    packet_header = f.read(16)
                    if len(packet_header) < 16:
                        break  # End of file
                    
                    ts_sec, ts_usec, incl_len, orig_len = struct.unpack('!IIII', packet_header)
                    
                    # Read packet data
                    packet_data = f.read(incl_len)
                    if len(packet_data) < incl_len:
                        break  # Incomplete packet
                    
                    total_packets += 1
                    
                    # Analyze packet type
                    packet_type = self._analyze_packet_data(packet_data, network)
                    packet_types[packet_type] += 1
                
                logger.info(f"Analyzed {total_packets} packets from {pcap_file}")
                return dict(packet_types)
                
        except Exception as e:
            logger.error(f"Error analyzing PCAP file {pcap_file}: {e}")
            return None
    
    def _analyze_packet_data(self, packet_data, network_type):
        """Analyze packet data to determine protocol/frame type."""
        try:
            if network_type == 127:  # IEEE 802.11 + Radiotap
                return self._analyze_wifi_packet(packet_data)
            elif network_type == 1:  # Ethernet
                return self._analyze_ethernet_packet(packet_data)
            else:
                return "Unknown"
        except Exception:
            return "Malformed"
    
    def _analyze_wifi_packet(self, packet_data):
        """Analyze WiFi packet with Radiotap header."""
        try:
            if len(packet_data) < 8:
                return "Malformed"
            
            # Parse Radiotap header
            rt_version, rt_pad, rt_len, rt_present = struct.unpack('<BBHI', packet_data[:8])
            
            if len(packet_data) < rt_len:
                return "Malformed"
            
            # Skip Radiotap header to get to 802.11 frame
            wifi_frame = packet_data[rt_len:]
            
            if len(wifi_frame) < 2:
                return "Malformed"
            
            # Parse 802.11 frame control
            fc = struct.unpack('<H', wifi_frame[:2])[0]
            frame_type = (fc >> 2) & 0x3
            frame_subtype = (fc >> 4) & 0xF
            
            # Classify based on frame type and subtype
            if frame_type == 0:  # Management frames
                management_subtypes = {
                    0: "Association Request",
                    1: "Association Response", 
                    2: "Reassociation Request",
                    3: "Reassociation Response",
                    4: "Probe Request",
                    5: "Probe Response",
                    6: "Timing Advertisement",
                    8: "Beacon",
                    9: "ATIM",
                    10: "Disassociation",
                    11: "Authentication",
                    12: "Deauthentication",
                    13: "Action Frame",
                    14: "Action No Ack",
                    15: "Reserved"
                }
                return management_subtypes.get(frame_subtype, f"Management (subtype {frame_subtype})")
            elif frame_type == 1:  # Control frames
                control_subtypes = {
                    7: "Control Wrapper",
                    8: "Block Ack Request",
                    9: "Block Ack",
                    10: "PS-Poll",
                    11: "RTS",
                    12: "CTS", 
                    13: "ACK",
                    14: "CF-End",
                    15: "CF-End+CF-Ack"
                }
                return control_subtypes.get(frame_subtype, f"Control (subtype {frame_subtype})")
            elif frame_type == 2:  # Data frames
                # Check for QoS data frames
                if frame_subtype & 0x8:  # QoS bit set
                    base_subtype = frame_subtype & 0x7
                    if base_subtype == 0:
                        return self._analyze_qos_data_frame(wifi_frame)
                    elif base_subtype == 4:
                        return "QoS Null Data"
                    else:
                        return f"QoS Data (subtype {frame_subtype})"
                else:  # Non-QoS data frames
                    if frame_subtype == 0:
                        return self._analyze_data_frame(wifi_frame)
                    elif frame_subtype == 4:
                        return "Null Data"
                    else:
                        return f"Data (subtype {frame_subtype})"
            else:
                return f"Reserved (type {frame_type})"
                
        except Exception:
            return "Malformed"
    
    def _analyze_data_frame(self, wifi_frame):
        """Analyze data frame to identify higher-layer protocols."""
        try:
            # Skip 802.11 header (varies, but typically 24-30 bytes)
            # For simplicity, we'll look for common patterns
            
            # Look for LLC/SNAP header (8 bytes: DSAP, SSAP, Control, OUI[3], Type[2])
            if len(wifi_frame) >= 32:
                # Try different offsets for 802.11 header
                for offset in [24, 26, 30]:
                    if offset + 8 <= len(wifi_frame):
                        llc_snap = wifi_frame[offset:offset+8]
                        if len(llc_snap) >= 8:
                            dsap, ssap, control = struct.unpack('BBB', llc_snap[:3])
                            if dsap == 0xAA and ssap == 0xAA and control == 0x03:
                                # SNAP header found
                                oui = llc_snap[3:6]
                                ethertype = struct.unpack('>H', llc_snap[6:8])[0]
                                
                                if ethertype == 0x0800:
                                    return self._analyze_ip_packet(wifi_frame[offset+8:])
                                elif ethertype == 0x0806:
                                    return "ARP"
                                elif ethertype == 0x86DD:
                                    return "IPv6"
                                else:
                                    return f"SNAP (0x{ethertype:04x})"
            
            return "Data (Encrypted/Unknown)"
        except Exception:
            return "Data (Malformed)"
    
    def _analyze_ip_packet(self, ip_data):
        """Analyze IP packet to identify protocol."""
        try:
            if len(ip_data) < 20:
                return "IP (Malformed)"
            
            # Parse IP header
            version_ihl = ip_data[0]
            protocol = ip_data[9]
            
            version = version_ihl >> 4
            if version != 4:
                return "IP (Non-IPv4)"
            
            if protocol == 1:
                return "ICMP"
            elif protocol == 2:
                return "IGMP"
            elif protocol == 6:
                # TCP - try to identify application protocol
                ihl = (version_ihl & 0xF) * 4
                if len(ip_data) >= ihl + 4:
                    src_port, dst_port = struct.unpack('>HH', ip_data[ihl:ihl+4])
                    # Check well-known ports
                    port_protocols = {
                        20: "FTP-DATA", 21: "FTP", 22: "SSH", 23: "Telnet",
                        25: "SMTP", 53: "DNS", 80: "HTTP", 110: "POP3",
                        143: "IMAP", 443: "HTTPS", 993: "IMAPS", 995: "POP3S",
                        465: "SMTPS", 587: "SMTP", 993: "IMAPS", 995: "POP3S",
                        3389: "RDP", 5432: "PostgreSQL", 3306: "MySQL"
                    }
                    
                    # Check destination port first, then source port
                    if dst_port in port_protocols:
                        return port_protocols[dst_port]
                    elif src_port in port_protocols:
                        return port_protocols[src_port]
                    else:
                        return f"TCP (port {dst_port})"
                return "TCP"
            elif protocol == 17:
                # UDP - try to identify application protocol
                ihl = (version_ihl & 0xF) * 4
                if len(ip_data) >= ihl + 4:
                    src_port, dst_port = struct.unpack('>HH', ip_data[ihl:ihl+4])
                    # Check well-known UDP ports
                    udp_protocols = {
                        53: "DNS", 67: "DHCP", 68: "DHCP", 69: "TFTP",
                        123: "NTP", 161: "SNMP", 162: "SNMP", 514: "Syslog",
                        520: "RIP", 1900: "SSDP", 5353: "mDNS"
                    }
                    
                    if dst_port in udp_protocols:
                        return udp_protocols[dst_port]
                    elif src_port in udp_protocols:
                        return udp_protocols[src_port]
                    else:
                        return f"UDP (port {dst_port})"
                return "UDP"
            elif protocol == 50:
                return "ESP (IPSec)"
            elif protocol == 51:
                return "AH (IPSec)"
            elif protocol == 89:
                return "OSPF"
            elif protocol == 103:
                return "PIM"
            else:
                return f"IP (protocol {protocol})"
                
        except Exception:
            return "IP (Malformed)"
    
    def _analyze_ethernet_packet(self, packet_data):
        """Analyze Ethernet packet."""
        try:
            if len(packet_data) < 14:
                return "Malformed"
            
            ethertype = struct.unpack('>H', packet_data[12:14])[0]
            
            if ethertype == 0x0800:
                return self._analyze_ip_packet(packet_data[14:])
            elif ethertype == 0x0806:
                return "ARP"
            elif ethertype == 0x86DD:
                return "IPv6"
            else:
                return f"Ethernet (0x{ethertype:04x})"
                
        except Exception:
            return "Malformed"
    
    def create_packet_type_pie_chart(self, pcap_file=None, output_file=None, show_plot=True):
        """Create a pie chart showing packet types by protocol."""
        # If no PCAP file specified, try to find one based on CSV file info
        if pcap_file is None:
            if hasattr(self, 'csv_file_path'):
                # Try to find corresponding PCAP file
                base_name = Path(self.csv_file_path).stem.replace('wifi_stats_', 'wifi_capture_')
                pcap_candidates = [
                    Path(self.csv_file_path).parent / f"{base_name}.pcap",
                    Path(self.csv_file_path).parent.parent / "captures" / f"{base_name}.pcap"
                ]
                
                for candidate in pcap_candidates:
                    if candidate.exists():
                        pcap_file = str(candidate)
                        break
                
                if pcap_file is None:
                    logger.error("No PCAP file specified and couldn't find matching PCAP file")
                    logger.info("Please specify a PCAP file with --pcap-file option")
                    return False
            else:
                logger.error("No PCAP file specified")
                return False
        
        # Check if PCAP file exists
        if not os.path.exists(pcap_file):
            logger.error(f"PCAP file not found: {pcap_file}")
            return False
        
        # Analyze PCAP file
        packet_types = self.analyze_pcap_file(pcap_file)
        if packet_types is None:
            return False
        
        if not packet_types:
            logger.warning("No packets found in PCAP file")
            return False
        
        # Create pie chart
        fig, ax = plt.subplots(1, 1, figsize=(10, 8), dpi=self.dpi)
        
        # Sort by count (descending) and group small categories
        sorted_types = sorted(packet_types.items(), key=lambda x: x[1], reverse=True)
        
        # Group small categories (< 0.5% of total) into "Other"
        total_packets = sum(packet_types.values())
        threshold = total_packets * 0.005  # 0.5% threshold
        
        labels = []
        sizes = []
        other_count = 0
        
        for ptype, count in sorted_types:
            if count >= threshold:
                labels.append(f"{ptype}\n({count:,} pkts)")
                sizes.append(count)
            else:
                other_count += count
        
        if other_count > 0:
            labels.append(f"Other\n({other_count:,} pkts)")
            sizes.append(other_count)
        
        # Create color palette
        colors = plt.cm.Set3(np.linspace(0, 1, len(labels)))
        
        # Create pie chart
        wedges, texts, autotexts = ax.pie(sizes, labels=labels, autopct='%1.1f%%', 
                                         colors=colors, startangle=90, pctdistance=0.85)
        
        # Beautify the chart
        for autotext in autotexts:
            autotext.set_color('white')
            autotext.set_fontweight('bold')
            autotext.set_fontsize(10)
        
        for text in texts:
            text.set_fontsize(9)
        
        ax.set_title(f'Packet Types Distribution\n{os.path.basename(pcap_file)}\nTotal: {total_packets:,} packets', 
                    fontsize=14, fontweight='bold', pad=20)
        
        # Add legend
        ax.legend(wedges, [label.split('\n')[0] for label in labels], 
                 title="Packet Types", loc="center left", bbox_to_anchor=(1, 0, 0.5, 1))
        
        plt.tight_layout()
        
        # Save plot if output file specified
        if output_file:
            try:
                plt.savefig(output_file, dpi=self.dpi, bbox_inches='tight')
                logger.info(f"Pie chart saved to: {output_file}")
            except Exception as e:
                logger.error(f"Error saving pie chart to {output_file}: {e}")
        
        # Show plot if requested
        if show_plot:
            plt.show()
        
        # Print statistics
        print("\n" + "="*60)
        print("PACKET TYPE ANALYSIS")
        print("="*60)
        for ptype, count in sorted_types[:10]:  # Top 10
            percentage = (count / total_packets) * 100
            print(f"{ptype:25} {count:8,} packets ({percentage:5.1f}%)")
        
        if len(sorted_types) > 10:
            remaining = sum(count for _, count in sorted_types[10:])
            remaining_pct = (remaining / total_packets) * 100
            print(f"{'Other types':25} {remaining:8,} packets ({remaining_pct:5.1f}%)")
        
        print("="*60 + "\n")
        
        return True
def find_latest_stats_file(directory="captures"):
    """Find the most recent WiFi statistics CSV file."""
    try:
        stats_files = list(Path(directory).glob("wifi_stats_*.csv"))
        if not stats_files:
            return None
        
        # Sort by modification time and return the newest
        latest_file = max(stats_files, key=lambda f: f.stat().st_mtime)
        return str(latest_file)
    except Exception as e:
        logger.error(f"Error finding stats files: {e}")
        return None

def main():
    """Main function."""
    parser = argparse.ArgumentParser(description='Plot WiFi capture statistics from CSV files')
    parser.add_argument('csv_file', nargs='?', help='CSV statistics file to plot (if not provided, will use the latest in captures/)')
    parser.add_argument('--output', '-o', help='Output file for saving the plot (PNG/PDF/SVG)')
    parser.add_argument('--histogram', action='store_true', help='Create histogram plot instead of time series')
    parser.add_argument('--pie-chart', action='store_true', help='Create pie chart of packet types by protocol')
    parser.add_argument('--pcap-file', help='PCAP file to analyze for pie chart (auto-detected if not specified)')
    parser.add_argument('--no-show', action='store_true', help='Do not display the plot window')
    parser.add_argument('--stats-only', action='store_true', help='Only print summary statistics, no plots')
    parser.add_argument('--captures-dir', default='captures', help='Directory to search for stats files (default: captures)')
    
    args = parser.parse_args()
    
    # Determine which CSV file to use
    csv_file = args.csv_file
    if not csv_file:
        csv_file = find_latest_stats_file(args.captures_dir)
        if not csv_file:
            logger.error(f"No WiFi statistics CSV files found in {args.captures_dir}/")
            logger.info("Make sure you've run create_pcap_file.py to generate statistics files")
            return 1
        logger.info(f"Using latest statistics file: {csv_file}")
    
    # Check if file exists
    if not os.path.exists(csv_file):
        logger.error(f"CSV file not found: {csv_file}")
        return 1
    
    # Create plotter and load data
    plotter = WiFiStatsPlotter()
    plotter.csv_file_path = csv_file  # Store for PCAP file detection
    if not plotter.read_csv_file(csv_file):
        return 1
    
    # Print summary statistics
    plotter.create_summary_stats()
    
    # Create plots if requested
    if not args.stats_only:
        show_plot = not args.no_show
        
        if args.pie_chart:
            # Create pie chart of packet types
            output_file = args.output or (f"{Path(csv_file).stem}_pie_chart.png" if args.output is not None else None)
            plotter.create_packet_type_pie_chart(args.pcap_file, output_file, show_plot)
        elif args.histogram:
            # Create histogram plot
            output_file = args.output or (f"{Path(csv_file).stem}_histogram.png" if args.output is not None else None)
            plotter.create_histogram_plot(output_file, show_plot)
        else:
            # Create time series plot
            output_file = args.output or (f"{Path(csv_file).stem}_timeseries.png" if args.output is not None else None)
            plotter.create_time_series_plot(output_file, show_plot)
    
    return 0

if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        logger.info("Interrupted by user")
        sys.exit(1)
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        sys.exit(1)
